# 2. 개략적인 규모 추정


> **개략적인 규모 추정(back-of-the-envelope estimation)**
> 
> 보편적으로 통용되는 성능 수치상에서 사고 실험(thought experiments)를 수행하여 추정치를 계산하는 것: **설계가 요구사항에 부합하는지 추정하는 것**

규모 추정을 위해서는 규모 확장성을 나타내는 표현들을 이해할 수 있어야한다.

## 1. 2의 제곱수

분산 시스템에서 다루는 데이터양을 계산할 때, 2의 제곱수로 표현할 수 있다.

* 1 byte == 8 bit == ASCII Char 1개

| 단위      | 2의 N 제곱 | (대략적) 바이트 수 | 설명                      |
|-----------|--------|------------|---------------------------|
| 1 KB      | 10     | 1천 바이트     | 킬로바이트 (Kilobyte)      |
| 1 MB      | 20     | 1백만 바이트    | 메가바이트 (Megabyte)      |
| 1 GB      | 30     | 10억 바이트    | 기가바이트 (Gigabyte)      |
| 1 TB      | 40     | 1조 바이트     | 테라바이트 (Terabyte)      |
| 1 PB      | 50     | 1000조 바이트  | 페타바이트 (Petabyte) |

## 2. 응답 지연값(Latency)

레이턴시는 시스템의 API 응답 속도를 이야기할 수도 있지만, 컴퓨터 내에서의 연산 속도도 레이턴시로 표현할 수 있다.

DC(데이터센터) 사이의 메시지 왕복 > 디스크에서 1MB씩 순차적으로 read > 네트워크에서 1MB 씩 순차적 read > 디스크 탐색(seek) > 같은 DC 내에서의 메시지 왕복 > 메모리에서 1MB 씩 read > 주 메모리 참조

> ❓표로 정리된 자료에는 디스크 탐색: 10ms, 디스크에서 1MB씩 순차 read: 30ms로 되어있는데 35p에 있는 시각화 수치에는 왜 디스크 탐색: 2ms, 디스크에서 1MB 씩 순차 read는 825마이크로초로 나오지?
> 아예 오래걸리는 작업 자체가 바뀌어버리는거 아닌가..

* 디스크 seek VS 디스크 read
  * 디스크 seek: 디스크에서 특정 데이터가 있는 위치를 찾는 시간 (디스크 회전, 헤드 이동 속도의 영향을 받음)
  * 디스크 read: 특정 포인트로부터 디스크 데이터를 순차적으로 읽는데 걸리는 시간
* 메모리 참조 VS 메모리 read
  * 메모리 참조: 특정 메모리 주소에 접근하는 속도 (주소 계산 및 접근만 수행)
  * 메모리의 연속된 데이터를 읽어오는 속도

**디스크 작업은 여전히 오래걸린다.**
**네트워크 전송 속도 >> 압축 속도이므로, 데이터를 압축한 후 전송하는 것이 레이턴시 감소에 도움이 된다.**


## 3. 가용성에 관계된 수치들

### 고가용성(HA)

High Availability의 약자로, **시스템이 오랜 시간 동안 지속적으로 중단없이 운영될 수 있는 능력**

* 퍼센트 단위로 표현 (100%는 중단된 적이 없음을 의미)
* 대부분 99%~100%
* 보통 시스템 업타임을 의미함


### SLA(Service Level Agreement)

서비스 제공자 - 고객 사이에 맺어지는 합의를 의미한다. (보통 서비스 가용시간이 SLA에 함께 명시된다.)

## 4. QPS와 저장소 요구량 측정 예제

> QPS: Query Per Second
> 
> * 쿼리란? 작은 단위의 개별 요청 (e.g., DB 쿼리 하나, 초당 API 호출 수 등)

* 일간 능동 사용자 수(DAU) = 월간 능동 사용자 수(MAU) * (평균 몇 %의 사용자가 서비스를 매일 사용하는지)
* QPS = (하루 전체 트윗량 = DAU * 한 명의 사용자가 평균 하루에 올리는 트윗량) / 24시간 / 60 / 60
* 최대 QPS(Peek QPS) = 2 * QPS
  *  2를 곱하는 이유는 보통 트래픽이 최대치로 뛰는 값이 평균 트래픽의 2배 정도일 때로 가정하고 곱하는 듯?
* 하루 동안 필요한 미디어 저장소 요구량 = (미디어를 포함한 트윗 비율%) * (하루 전체 트윗량) * (미디어 하나의 크기)
* N년간 필요한 미디어 저장소 요구량 = (하루 동안 필요한 미디어 저장소 요구량) * 365 * N

<img width="722" alt="image" src="https://github.com/user-attachments/assets/cb9dcd49-3c88-4257-8c4b-e1deb3e5a05a">


궁금한 점 

- 새로운 내용이  주 DB에 써지면 언제 어떻게 부 DB로 전송이 돼서 가용성이 유지되는 걸까?
    - batch를 쓰는거면 실시간이 아닌거고, 실시간으로 insert를 모든 부 DB에 처리해줘야하는 거면 비효율적인거 같다는 생각이 든다 → 궁금함!
<br><br><br>

# 궁금한 점에 대한 설명

데이터베이스 리플리케이션

- 데이터베이스 리플리케이션은 실시간 복제본 데이터베이스 서버를 운용하는 것을 의미한대
    - 어떻게?
        - 기준이 되는 마스터 서버, 마스터 서버와 동일한 내용을 갖는 리플리카(slave)
            - 마스터는 쓰기 작업
            - slave에는 읽기 작업

- 리플리카 서버는 ‘아주 약간’의 딜레이가 있지만 거의 실시간으로 마스터 서버와 동일한 데이터를 복제하고 있기 때문에 데이터 소실의 최소화가 가능하다
    - 어떻게?

리플리케이션 동작 원리

- 비동기 복제 방식을 사용하고 있음(mariaDB)
    - 마스터 서버 : 데이터 변경 작업을 처리하고 변경 사항을 리플리카에 전달 → slave : 마스터의 데이터를 복제 후 읽기 작업에 사용

이력 기록 → 로그 전송 → 로그 재생

1. 이력 기록 : 
    1. 마스터에서 변경되는 데이터에 대한 이력을 바이너리 로그에 기록함
    2. 바이너리 로그에는 변경된 데이터 값 + 데이터 변경을 트리거한 SQL 명령어까지 기록되어 있음
2. 로그 전송 : 
    1. 마스터의 Replication Master Thread가 바이너리 로그에서 데이터를 읽어옴
    2. 읽은 로그 데이터를 slave에게 비동기적으로 전송함
3. 로그 재생
    1. slave는 마스터로부터 전달받은 로그 데이터를 Relay Log라는 임시 저장소에 저장함
    2. slave의 SQL Thread 는 Realy Log를 읽어, SQL 명령어를 실행하여 마스터와 데이터를 동기화 한다.

비동기 복제

- 마스터 서버는 로그를 slave에 전송한 이후 다른 작업을 처리할 수 있음
- slave가 로그를 수신, 처리하는 과정은 독립적으로 진행되므로, 마스터 서버의 쓰기 성능에 영향 미치지 않는다

<br><br><br>


## 동시성 이슈는 무조건 발생하는 설계임.

하지만 결국 시간의 지연이 생기기 마련이다. 그래서 데이터 일관성이 깨질 수 있다.

was 1 - 부 DB1

was 2 - 부 DB2

was 3 - 부 DB3

이렇게 연결되어 있는데 insert이후 바로 was1,2,3에 동시에 같은 요청 들어오면 서로 다른 데이터를 응답으로 보낼 확률 높음

( 주 DB에서 데이터를 갱신했지만, 부 DB1에는 반영되었고 부 DB2, 부 DB3에는 반영되지 않았을 가능성.)

<br>
<br>
<br>



### 원인이 뭘까?

- 구조적으로 부 DB는 변경 사항을 즉시 반영하지 못함
    - 주 DB는 최신 데이터로 갱신되었더라도, 부 DB는 여전히 상태가 남아있음

<br>
<br>
<br>

### 해결 방법

1. 주 DB를 쓰기 + 읽기로 사용 : 
    1. 쓰기 작업 직후 읽기 작업이 바로 필요한 경우, 주 DB의 데이터를 읽음 == 프록시 도입
    2. 단, 이렇게 하면 주 DB 부하생김
2. 세션 기반 읽기 방식 적용
    1. 특정 요청(Session)이 시작된 이후 읽기 요청은 쓰기 작업이 부 DB에 모두 반영된 후 처리하도록 보장
        1. WAS1이 주 DB에 쓰기를 요청한 후, 읽기 요청은 항상 주 DB 또는 최신 상태를 반영한 부 DB에서 처리.
    2. 구현 복잡도가 굉장히 증가함…
3. 부 DB 동기복제 사용
    1. 주 DB와 부 DB간의 동기 복제를 하여 모든 데이터 변경 사항을 즉시 부 DB에 반영

→ 개인적으로 1번 해결방법이 가장 현실적이라 생각함…
